PQI(Sv, Sh, C, Q, I)

pour tout J, Pi(Sv)(J) = I, J satisfy C, J satisfy Q

CQ vues



Height of the tree = R x n^r x (| Q | + 1)
R : nb Relation
n : nb of values exported
r : arity
Q : taille du secret

Size of the tree = | nb of facts | ^ (height) +1

nb of facts : max(foreach relation, get the nb of constraints which can be matched)

corriger la génération : toutes les variables doivent être différentes

--------------------------------------------------------------------------------------

Unification pendant, retenir tuples déjà générés


But : proof concept/prototype
pourquoi les gens n'ont pas fait le projet avant ? pleins d'implémentation du case. Unification c'est nouveau. (unificiation dû à la visibilité)
(chercher chase sur Internet)
Est ce que c'est mieux de faire l'unification pendant ?

changer formule selon taille du cycle maximale
et bien en parler dans le rapport : est ce que ça change en pratique ?

NP-hard : on réduit notre problème (il existe PQI) à un autre problème d'inclusions de requêtes (C1 inclu C2) pour un problème d'arité 2 [foundation of database]
Soit Q1 et Q2 (deux requ^tes conjonctives booléennes) et S un schéma d'arité 2 (arité doit petre bornée)

S -> Sh U ( HOKQ1(x) )
Sv -> { VOKQ1(x) } // dit que la requete est vraie
Sh -> { VOKQ1 (x) }

VOKQ1(x) equivalent HOKQ1(x) ^ Q1 

il existe PQi(Sh, Sv, C, Q2) ssi Q1 inclu dans Q2

_______

Il existe PQI(Sh, Sv, C, Q2)
-> Th LICS
PQI (Sh, Sv, C, Q2, I{a})
-> Th LICS
chase + unificiation (C, I{a}) satisfait Q2
-> Calcul du chase
(HOKQ1(a), VOKQ1{a}) U IQ1 satisfait Q2
-> justifier que toutes les valeurs de IQ1 sont différentes de a
-> donc on peut enlever les HOKQ(a) et VOKQ(a)
Iq1 satisfait Q2
-> Th [ Foundation of database ]
Il existe h tel que Q2 implique homomorphiquement Q1
-> Th [Foundation of database]
Q1 inclu Q2




----------------------------------------------------------------------------------------

Intro : 

But : faire un prototype pour vérifier des trous de sécurité dans des vues de base de données
Est ce qu'on peut déduire des choses qui auraient dû rester cachées.

Expliquer : ce qu'est une vue de base de données, un tour de sécurité

Motivation :
Les bases de données n'affichent pas toutes les données mais seulement une partie, des vues.
Ces vues sont définies par des formules logiques.
Un utilisateur peut déduire des vues et de formules logiques des faits cachés
Faire un exemple (pourquoi pas avec le schém de Cristal)


De plus, on connaît des propriétés sur les bases de données comme des clefs étrangères. Avec les vues et les clefs, on peut déduire de nouvelles choses.


V1, V2, Phi1, Phi2, C => permet de déduire un secret

Pour Phi1, Phi2, C, S; Est ce qu'il existe V1, V2 tq Phi1, Phi2, C je peux déduire S

Security by Design -> on s'intéresse au schéma et pas aux données



Résultats théoriques généraux -> Papiers LICS
-> faire un prototype pour un cadre restreint mais pratique pour montrer la faisabilité

-----


Pq c'est compliqué : Algo en Pspace complet
Pas de méthodes existantes, approche complexe.

Préliminaire : 
Qu'est ce qu'une base de données : Livre Fundation of database (sur Internet en anglais)
Vue : CQ vue
Contrainte : dépendance d'inclusion
Secret : CQ

Technique : 
- évaluation CQ
- Homomorphisme
- Chase

Définition des problèmes
PQI

Il existe PQI

Fin des préliminaires

Résolution :

Il existe PQI
Citer : LICS : il existe PQI equivalent PQI avec I{a}
Attention à la citation.

Se restreindre à PQI I{a}

D'abord : Faire la résolution d'abord avec les CQ view.
Expliquer l'algo, prendre un exemple
NP Complet (LICS)
Chase + unification -> correcte (LICS)

Expériences : montrer l'intérêt et les limites
Générateur

2e Clef et atomic vue : atomic vue est une vue définie par une seule table , genre R(x,y) -> S(y, z)
supprimer les colonnes et ne pas faire d'unification OU faire l'unification APRES la génération avec les clefs
expliquer pourquoi on a pas d'arbre mais juste un compteur

expériences :


perspective pour la suite : unifier les 2 algos : CQ view et clef (qui est le cas pratique en général)


-------------------------------------------------------

Regarder le cycles le plus grand avec un élément de la requete dedans (car p-e des cycles plus grands mais aps d'éléments de requêtes dedans)
Regarder redondance entre éléments homomorphique s(et donc arrêter génération)

Regarder Schéma cristal pour nombre de clef étrangère